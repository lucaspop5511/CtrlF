Lista simplu inlantuita : ( 
// Definire structura Nod 
typedef struct Nod {
    int valoare;
    struct Nod* next;
} Nod;
void INSERT(Nod** cap, int valoare) {
    Nod* newNode = (Nod*)malloc(sizeof(Nod));
    newNode->valoare = valoare;
    newNode->next = *cap;
    *cap = newNode;
}
)

Hash Table : (
typedef struct {
    int key;
    int value;
} HashEntry;
#define TABLE_SIZE 100
HashEntry* hashTable[TABLE_SIZE];
int hashFunction(int key) {
    return key % TABLE_SIZE;
}
void INSERT(int key, int value) {
    int index = hashFunction(key);
    hashTable[index] = (HashEntry*)malloc(sizeof(HashEntry));
    hashTable[index]->key = key;
    hashTable[index]->value = value;
}
)

Quicksort : (
void swap(int* a, int* b) {
    int t = *a;
    *a = *b;
    *b = t;
}
int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = (low - 1);
    for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
)

Heap Sort : (
void heapify(int arr[], int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    if (left < n && arr[left] > arr[largest])
        largest = left;
    if (right < n && arr[right] > arr[largest])
        largest = right;
    if (largest != i) {
        swap(&arr[i], &arr[largest]);
        heapify(arr, n, largest);
    }
}
void heapSort(int arr[], int n) {
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);
    for (int i = n - 1; i >= 0; i--) {
        swap(&arr[0], &arr[i]);
        heapify(arr, i, 0);
    }
}
)

Sortare prin Insertie (Insertion Sort) : (
void insertionSort(int arr[], int n) {
    int i, key, j;
    for (i = 1; i < n; i++) {
        key = arr[i];
        j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}
)

Sortare prin Selectie (Selection Sort) : (
void selectionSort(int arr[], int n) {
    int i, j, min_idx;
    for (i = 0; i < n - 1; i++) {
        min_idx = i;
        for (j = i + 1; j < n; j++)
            if (arr[j] < arr[min_idx])
                min_idx = j;
        int temp = arr[min_idx];
        arr[min_idx] = arr[i];
        arr[i] = temp;
    }
}
)

Sortare Topologica : (
void topSort(int v, 
            int visited[], 
            StackNode** stack, 
            int graph[5][5]) {
    visited[v] = 1;
    for (int i = 0; i < 5; i++)
        if (graph[v][i] && !visited[i])
            topSort(i, visited, stack, graph);
    *stack = push(*stack, v);
}
void topSort(int graph[5][5]) {
    StackNode* stack = NULL;
    int visited[5] = {0};
    for (int i = 0; i < 5; i++)
        if (!visited[i])
            topSort(i, visited, &stack, graph);
    while (stack != NULL)
        printf("%d ", pop(&stack));
}
)

Stiva (LIFO) : (
typedef struct {
    int data;
    struct StackNode* next;
} StackNode;
StackNode* push(StackNode* top, int data) {
    StackNode* newNode = (StackNode*)malloc(sizeof(StackNode));
    newNode->data = data;
    newNode->next = top;
    return newNode;
}
int pop(StackNode** top) {
    if (*top == NULL) return -1;
    int data = (*top)->data;
    StackNode* temp = *top;
    *top = (*top)->next;
    free(temp);
    return data;
}
)

Coada (FIFO) : (
typedef struct {
    int data;
    struct QueueNode* next;
} QueueNode;
typedef struct {
    QueueNode *front, *rear;
} Queue;
void enqueue(Queue* q, int data) {
    QueueNode* newNode = (QueueNode*)malloc(sizeof(QueueNode));
    newNode->data = data;
    newNode->next = NULL;
    if (q->rear == NULL) {
        q->front = q->rear = newNode;
        return;
    }
    q->rear->next = newNode;
    q->rear = newNode;
}
int dequeue(Queue* q) {
    if (q->front == NULL) return -1;
    int data = q->front->data;
    QueueNode* temp = q->front;
    q->front = q->front->next;
    if (q->front == NULL) q->rear = NULL;
    free(temp);
    return data;
}
)

Algoritmul lui Dijkstra : (
#define INF 99999
void dijkstra(int graph[5][5], int src) {
    int dist[5]; 
    int visited[5] = {0};
    for (int i = 0; i < 5; i++)
        dist[i] = INF;
    dist[src] = 0;
    for (int count = 0; count < 5 - 1; count++) {
        int min = INF, min_index;
        for (int v = 0; v < 5; v++)
            if (!visited[v] && dist[v] <= min)
                min = dist[v], min_index = v;
        visited[min_index] = 1;
        for (int v = 0; v < 5; v++)
            if (!visited[v] && graph[min_index][v] 
                    && dist[min_index] != INF 
                    && dist[min_index] + graph[min_index][v] < dist[v])
                dist[v] = dist[min_index] + graph[min_index][v];
    }
}
)

Determinarea componentelor conexe ale unui graf : (
void DFS(int v, int visited[], int graph[5][5]) {
    visited[v] = 1;
    printf("%d ", v);
    for (int i = 0; i < 5; i++)
        if (graph[v][i] && !visited[i])
            DFS(i, visited, graph);
}
void findConnectedComponents(int graph[5][5]) {
    int visited[5] = {0};
    for (int v = 0; v < 5; v++)
        if (!visited[v]) {
            printf("Componenta: ");
            DFS(v, visited, graph);
            printf("\n");
        }
}
)

Algoritmul lui Floyd-Warshall pentru drumuri minime in grafuri : (
#define INF 99999
void floydWarshall(int graph[][3], int n) {
    for (int k = 0; k < n; k++)
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                if (graph[i][k] + graph[k][j] < graph[i][j])
                    graph[i][j] = graph[i][k] + graph[k][j];
}
)

Backtracking â€“ Generarea permutarilor unui sir : (
void swap(char *x, char *y) {
    char temp = *x;
    *x = *y;
    *y = temp;
}
void permute(char *str, int l, int r) {
    if (l == r) {
        printf("%s\n", str);
        return;
    }
    for (int i = l; i <= r; i++) {
        swap(&str[l], &str[i]);
        permute(str, l + 1, r);
        swap(&str[l], &str[i]);
    }
}
)

Algoritmul BFS : (
void BFS(int graph[5][5], int start) {
    int visited[5] = {0};
    Queue q = {NULL, NULL};
    enqueue(&q, start);
    visited[start] = 1;
    while (q.front != NULL) {
        int node = dequeue(&q);
        printf("%d ", node);
        for (int i = 0; i < 5; i++) {
            if (graph[node][i] && !visited[i]) {
                enqueue(&q, i);
                visited[i] = 1;
            }
        }
    }
}
)

Cautare Binomiala (Exponentiala) : (
int binarySearch(int arr[], int l, int r, int x) {
    while (l <= r) {
        int mid = l + (r - l) / 2;
        if (arr[mid] == x) return mid;
        if (arr[mid] < x) l = mid + 1;
        else r = mid - 1;
    }
    return -1;
}
int exponentialSearch(int arr[], int n, int x) {
    if (arr[0] == x) return 0;
    int i = 1;
    while (i < n && arr[i] <= x)
        i *= 2;
    return binarySearch(arr, i / 2, fmin(i, n - 1), x);
}
)

Numere Fibonacci cu programare dinamica : (
int fibonacci(int n) {
    int f[n + 2];
    f[0] = 0;
    f[1] = 1;
    for (int i = 2; i <= n; i++)
        f[i] = f[i - 1] + f[i - 2];
    return f[n];
}
)

Algoritmul lui Kruskal pentru arbori acoperitori minimi : (
typedef struct {
    int src, dest, weight;
} Edge;
int findParent(int parent[], int i) {
    if (parent[i] == i) return i;
    return findParent(parent, parent[i]);
}

void unionSets(int parent[], int rank[], int x, int y) {
    int rootX = findParent(parent, x);
    int rootY = findParent(parent, y);
    if (rank[rootX] < rank[rootY])
        parent[rootX] = rootY;
    else if (rank[rootX] > rank[rootY])
        parent[rootY] = rootX;
    else {
        parent[rootY] = rootX;
        rank[rootX]++;
    }
}
)

Numarul maxim de activitati care nu se suprapun (Greedy) : (
void activitySelection(int start[], int finish[], int n) {
    int i = 0;
    printf("Activite selectate: %d ", i);
    for (int j = 1; j < n; j++) {
        if (start[j] >= finish[i]) {
            printf("%d ", j);
            i = j;
        }
    }
}
)